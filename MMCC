from numpy import random
import matplotlib.pyplot as plt

ARRIVAL = 1
DEPARTURE = 2

class Customer:
    time = 0 #arrivalTime, named this to save me from having to rewrite the same function twice
    departureTime = 0 #time the customer left our system
    serviceStartTime = 0 #time the customer began service (after waiting)
    waitedTime = 0 #time between customer arrival and service
    serviceTime = 0 #time the customer was using our service
    timeInServer = 0 #total time in our servers

    def __init__(self, arrivalTime):
        self.time = arrivalTime

    def ServeCustomer(self, startServiceTime, serviceRate):
        self.waitedTime = startServiceTime - self.time
        self.serviceStartTime = startServiceTime
        self.departureTime = startServiceTime + random.exponential(serviceRate, size=1)
        self.serviceTime = self.departureTime - self.serviceStartTime
        self.timeInServer = self.departureTime - self.time
        return self.departureTime

class Event:
    type = DEPARTURE
    time = 0
    relevantCustomer = None

    def __init__(self, type, time, customer):
        self.type = type
        self.time = time
        self.relevantCustomer = customer

class Server:
    busyUntil = 0 #time this channel is busy for
    timeSpentBusy = 0

    def Serve(self, customer, time, serviceRate): #a customer has arrived and has been assigned to this server
        customerDeparture = customer.ServeCustomer(time, serviceRate)
        self.busyUntil = customerDeparture
        self.timeSpentBusy += customerDeparture - time
        return Event(DEPARTURE, customerDeparture, customer)

def GetServer(servers, time): #get the most available server
    bestServer = None
    bestScore = 0
    for s in servers: #compare every server to find the best
        sBusyUntil = s.busyUntil #higher is worse
        if time >= sBusyUntil and (bestServer == None or sBusyUntil < bestScore): #if this server is less busy (and exists)
            bestServer = s #least busy server
            bestScore = sBusyUntil
    return bestServer

def InsertByVar(objList, newObj): #insert element in list based on time
    #find relevant position where the obj should be placed
    i = 0
    for i, obj in enumerate(objList):
        if obj.time >= newObj.time: #new element is worse than this element
            break #break and use the i index
        elif i == len(objList) - 1: #this is the highest time
            i += 1 #raise the index so it gets placed at the end

    #insert the new obj in the correct position
    objList.insert(i, newObj)
    return objList

def DrawFigures(results):
    plt.figure(figsize=(12, 6))

    arrivalRate, utilization, customersTotal, blockingProbability = zip(*results)

    #blocking probability as arrival rate increases
    plt.subplot(1, 2, 1)
    plt.plot(arrivalRate, blockingProbability) 
    plt.title('Blocking Probability vs Arrival Rate')
    plt.xlabel('Arrival Rate (calls/second)')
    plt.ylabel('Blocking Probability')
    plt.grid(True)

    #server utilization as arrival rate increases
    plt.subplot(1, 2, 2)
    plt.plot(arrivalRate, utilization, marker='o')
    plt.title('Server Utilization vs Arrival Rate')
    plt.xlabel('Arrival Rate (calls/second)')
    plt.ylabel('Server Utilization')
    plt.grid(True)

    plt.tight_layout()
    plt.show(block=True)

def Simulate(arrivalRate, serviceRate, timeMax, c):
    #setup
    time = 0
    customersServed = []
    customersBlocked = []
    servers = []
    eventList = []

    for i in range(c):
        servers.append(Server())

    nextArrival = 0
    while time < timeMax:
        #generate customer
        if nextArrival <= time:
            customer = Customer(time)
            nextArrival = time + random.poisson(1/arrivalRate, size=1)
            eventList = InsertByVar(eventList, Event(ARRIVAL, time, customer))

        #if the server has nothing to do, idle until next customer comes, alternatively if it is waiting for too long also have a customer arrive
        if len(eventList) == 0 or (len(eventList) > 0 and eventList[0].time > nextArrival):
            time = nextArrival
            continue

        #gather event stats
        event = eventList[0] #ARRIVAL, DEPARTURE
        eventType = event.type
        time = event.time #time of event
        customer = event.relevantCustomer #reference to the customer in question

        #depending on the event type, decide what to do
        departureEvent = None #we may have a departure event if we successfully queued a customer
        if eventType == ARRIVAL: #customer has just arrived, assign them to a server
            #find an available server
            nextServer = GetServer(servers, time) 
            if nextServer == None: #all servers are busy
                customersBlocked.append(customer)
            else:
                #assign the customer to the relevant server and start the server processing
                departureEvent = nextServer.Serve(customer, time, serviceRate) #departure event of this customer
        elif eventType == DEPARTURE: #customer has just finished being served
            customersServed.append(customer)

        eventList.remove(event)

        if departureEvent != None: 
            eventList = InsertByVar(eventList, departureEvent) #append when the server will be finished

    cumuServerBusy = 0
    for s in servers:
        cumuServerBusy += s.timeSpentBusy

    utilization = cumuServerBusy / (c * timeMax)
    customersTotal = len(customersServed) + len(customersBlocked)
    blockingProbability = len(customersBlocked) / customersTotal

    return utilization, customersTotal, blockingProbability

random.seed(5) #set the randomness to be consistent
timeMax = 1000
c = 16 #servers
serviceRate = 100

results = []
for i in range(1, 11): #0.1-1
    arrivalRate = 0.01 * i
    utilization, customersTotal, blockingProbability = Simulate(arrivalRate, serviceRate, timeMax, c)
    results.append((arrivalRate, utilization, customersTotal, blockingProbability))

DrawFigures(results)
